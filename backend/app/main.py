"""FastAPI entrypoint wiring the ChatKit server and REST endpoints."""

from __future__ import annotations

import logging

import httpx
from chatkit.server import StreamingResult
from fastapi import Depends, FastAPI, HTTPException, Request, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, Response, StreamingResponse
from starlette.responses import JSONResponse

logger = logging.getLogger(__name__)

from .chat import (
    REPORTS_DIR,
    TraccarAssistantServer,
    create_chatkit_server,
)
from .traccar import _get_cookie, _get_traccar_url

app = FastAPI(title="ChatKit API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

_chatkit_server: TraccarAssistantServer | None = create_chatkit_server()


def _real_ip(request: Request) -> str:
    """Get the real client IP behind Cloudflare (o2o worker setup)."""
    xff = request.headers.get("X-Forwarded-For", "")
    if xff:
        return xff.split(",")[0].strip()
    return request.headers.get("CF-Connecting-IP") or (request.client.host if request.client else "unknown")


@app.middleware("http")
async def log_requests(request: Request, call_next):
    ip = _real_ip(request)
    logger.info("%s %s %s %s", ip, request.method, request.url.path, request.headers.get('cf-ipcountry'))
    return await call_next(request)


def get_chatkit_server() -> TraccarAssistantServer:
    if _chatkit_server is None:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=(
                "ChatKit dependencies are missing. Install the ChatKit Python "
                "package to enable the conversational endpoint."
            ),
        )
    return _chatkit_server


@app.api_route("/api/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def proxy_traccar(request: Request, path: str) -> Response:
    """Reverse-proxy /api/* requests to the Traccar server."""
    traccar_url = f"{_get_traccar_url(request).rstrip('/')}/api/{path}"
    if request.url.query:
        traccar_url += f"?{request.url.query}"

    cookie = _get_cookie(request)
    headers = {"Accept": "application/json"}
    if cookie:
        headers["Cookie"] = cookie
    content_type = request.headers.get("content-type")
    if content_type:
        headers["Content-Type"] = content_type

    body = await request.body()

    async with httpx.AsyncClient() as client:
        resp = await client.request(
            request.method,
            traccar_url,
            headers=headers,
            content=body or None,
        )

    excluded = {"transfer-encoding", "content-encoding", "content-length"}
    resp_headers = {
        k: v for k, v in resp.headers.items() if k.lower() not in excluded
    }
    return Response(content=resp.content, status_code=resp.status_code, headers=resp_headers)


@app.get("/chatkit/{filename}")
async def get_file(filename: str) -> Response:
    """Serve report files generated by the chat assistant."""
    file_path = REPORTS_DIR / filename

    # Security check: ensure the file is within the reports directory
    if not file_path.is_relative_to(REPORTS_DIR):
        raise HTTPException(status_code=400, detail="Invalid file path")

    if not file_path.exists():
        raise HTTPException(status_code=404, detail="Report file not found")

    # Determine media type based on file extension
    if filename.endswith(".html"):
        # Serve HTML directly in browser
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
        return Response(content=content, media_type="text/html")
    elif filename.endswith(".png"):
        return FileResponse(path=file_path, media_type="image/png")
    else:
        # Serve JSON files
        return FileResponse(path=file_path, media_type="application/json", filename=filename)


@app.post("/chatkit")
async def chatkit_endpoint(
    request: Request, server: TraccarAssistantServer = Depends(get_chatkit_server)
) -> Response:
    payload = await request.body()
    result = await server.process(payload, {"request": request})
    if isinstance(result, StreamingResult):
        return StreamingResponse(result, media_type="text/event-stream")
    if hasattr(result, "json"):
        return Response(content=result.json, media_type="application/json")
    return JSONResponse(result)


@app.get("/health")
async def health_check() -> dict[str, str]:
    return {"status": "healthy"}
